#include "stdio.h"
#include "string.h"
#include "bt_encrypt.h"

#include "alg/cmac.h"
#include "alg/uECC.h"
#include "alg/ccm.h"

#define brev(data, len) \
	do{int l=len/2;\
		while(l--){\
			uint8_t t = ((uint8_t*)data)[l];\
			((uint8_t*)data)[l] = ((uint8_t*)data)[len-l-1];\
			((uint8_t*)data)[len-l-1] = t;\
		}\
	}while(0)

void test(void)
{
	uint8_t out[32];
#ifndef DUMP
#define DUMP(d,l) do{int i;for(i=0;i<l;i++)printf("%02X ", ((uint8_t*)d)[i]); puts("");}while(0)
#endif
	/******************************************************
	  D.1 AES-CMAC RFC4493 TEST VECTORS
	  The following test vectors are referenced from RFC4493.
	  K 2b7e1516 28aed2a6 abf71588 09cf4f3c
	  Subkey Generation
	  AES_128(key,0) 7df76b0c 1ab899b3 3e42f047 b91b546f
	  K1 fbeed618 35713366 7c85e08f 7236a8de
	  K2 f7ddac30 6ae266cc f90bc11e e46d513b
	 ******************************************************/
	{
		uint8_t k[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
		memset(out, 0, 16); btc_e(k, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.1.1 Example 1: Len = 0
	  M <empty string>
	  AES_CMAC bb1d6929 e9593728 7fa37d12 9b756746
	 ******************************************************/
	{
		uint8_t k[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
		btc_aes_cmac(k, NULL, 0, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.1.2 Example 2: Len = 16
	  M 6bc1bee2 2e409f96 e93d7e11 7393172a
	  AES_CMAC 070a16b4 6b4d4144 f79bdd9d d04a287c
	 ******************************************************/
	{
		uint8_t k[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
		uint8_t d[] = {
			0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		};
		btc_aes_cmac(k, d, 16, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.1.3 Example 3: Len = 40
	  M0 6bc1bee2 2e409f96 e93d7e11 7393172a
	  M1 ae2d8a57 1e03ac9c 9eb76fac 45af8e51
	  M2 30c81c46 a35ce411
	  AES_CMAC dfa66747 de9ae630 30ca3261 1497c827
	 ******************************************************/
	{
		uint8_t k[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
		uint8_t d[] = {
			0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
			0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
			0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,
		};
		btc_aes_cmac(k, d, 40, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.1.4 Example 4: Len = 64
	  M0 6bc1bee2 2e409f96 e93d7e11 7393172a
	  M1 ae2d8a57 1e03ac9c 9eb76fac 45af8e51
	  M2 30c81c46 a35ce411 e5fbc119 1a0a52ef
	  M3 f69f2445 df4f9b17 ad2b417b e66c3710
	  AES_CMAC 51f0bebf 7e3b9d92 fc497417 79363cfe
	 ******************************************************/
	{
		uint8_t k[] = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
		uint8_t d[] = {
			0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
			0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
			0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
			0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10,
		};
		btc_aes_cmac(k, d, 64, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.2 f4 LE SC CONFIRM VALUE GENERATION FUNCTION
	  U 20b003d2 f297be2c 5e2c83a7 e9f9a5b9
	  eff49111 acf4fddb cc030148 0e359de6
	  V 55188b3d 32f6bb9a 900afcfb eed4e72a
	  59cb9ac2 f19d7cfb 6b4fdd49 f47fc5fd
	  X d5cb8454 d177733e ffffb2ec 712baeab
	  Z 0x00
	  M0 20b003d2 f297be2c 5e2c83a7 e9f9a5b9
	  M1 eff49111 acf4fddb cc030148 0e359de6
	  M2 55188b3d 32f6bb9a 900afcfb eed4e72a
	  M3 59cb9ac2 f19d7cfb 6b4fdd49 f47fc5fd
	  00
	  AES_CMAC f2c916f1 07a9bd1c f1eda1be a974872d
	 ******************************************************/
	{
		uint8_t u[] = {
			0x20,0xb0,0x03,0xd2,0xf2,0x97,0xbe,0x2c,0x5e,0x2c,0x83,0xa7,0xe9,0xf9,0xa5,0xb9,
			0xef,0xf4,0x91,0x11,0xac,0xf4,0xfd,0xdb,0xcc,0x03,0x01,0x48,0x0e,0x35,0x9d,0xe6,
		};
		uint8_t v[] = {
			0x55,0x18,0x8b,0x3d,0x32,0xf6,0xbb,0x9a,0x90,0x0a,0xfc,0xfb,0xee,0xd4,0xe7,0x2a,
			0x59,0xcb,0x9a,0xc2,0xf1,0x9d,0x7c,0xfb,0x6b,0x4f,0xdd,0x49,0xf4,0x7f,0xc5,0xfd,
		};
		uint8_t x[] = {
			0xd5,0xcb,0x84,0x54,0xd1,0x77,0x73,0x3e,0xff,0xff,0xb2,0xec,0x71,0x2b,0xae,0xab,
		};
		uint8_t z = 0;
		btc_f4(u, v, x, z, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.3 f5 LE SC KEY GENERATION FUNCTION
	  DHKey(W) ec0234a3 57c8ad05 341010a6 0a397d9b
	  99796b13 b4f866f1 868d34f3 73bfa698
	  T 3c128f20 de883288 97624bdb 8dac6989
	  keyID 62746c65
	  N1 d5cb8454 d177733e ffffb2ec 712baeab
	  N2 a6e8e7cc 25a75f6e 216583f7 ff3dc4cf
	  A1 00561237 37bfce
	  A2 00a71370 2dcfc1
	  Length 0100
	  (LTK)
	  M0 0162746c 65d5cb84 54d17773 3effffb2
	  M1 ec712bae aba6e8e7 cc25a75f 6e216583
	  M2 f7ff3dc4 cf005612 3737bfce 00a71370
	  M3 2dcfc101 00
	  AES_CMAC 69867911 69d7cd23 980522b5 94750a38
	  (MacKey)
	  M0 0062746c 65d5cb84 54d17773 3effffb2
	  M1 ec712bae aba6e8e7 cc25a75f 6e216583
	  M2 f7ff3dc4 cf005612 3737bfce 00a71370
	  M3 2dcfc101 00
	  AES_CMAC 2965f176 a1084a02 fd3f6a20 ce636e20
	 ******************************************************/
	{
		uint8_t w[] = {
			0xec,0x02,0x34,0xa3,0x57,0xc8,0xad,0x05,0x34,0x10,0x10,0xa6,0x0a,0x39,0x7d,0x9b,
			0x99,0x79,0x6b,0x13,0xb4,0xf8,0x66,0xf1,0x86,0x8d,0x34,0xf3,0x73,0xbf,0xa6,0x98,
		};
		uint8_t n1[] = {
			0xd5,0xcb,0x84,0x54,0xd1,0x77,0x73,0x3e,0xff,0xff,0xb2,0xec,0x71,0x2b,0xae,0xab,
		};
		uint8_t n2[] = {
			0xa6,0xe8,0xe7,0xcc,0x25,0xa7,0x5f,0x6e,0x21,0x65,0x83,0xf7,0xff,0x3d,0xc4,0xcf,
		};
		uint8_t a1[] = { 0x00,0x56,0x12,0x37,0x37,0xbf,0xce, };
		uint8_t a2[] = { 0x00,0xa7,0x13,0x70,0x2d,0xcf,0xc1, };
		btc_f5(w, n1, n2, a1, a2, out);
		DUMP(((uint8_t*)&out[16]), 16);
		DUMP(((uint8_t*)&out[0]), 16);
	}


	/******************************************************
	  D.4 f6 LE SC CHECK VALUE GENERATION FUNCTION
	  N1 d5cb8454 d177733e ffffb2ec 712baeab
	  N2 a6e8e7cc 25a75f6e 216583f7 ff3dc4cf
	  MacKey 2965f176 a1084a02 fd3f6a20 ce636e20
	  R 12a3343b b453bb54 08da42d2 0c2d0fc8
	  IOcap 010102
	  A1 00561237 37bfce
	  A2 00a71370 2dcfc1
	  M0 d5cb8454 d177733e ffffb2ec 712baeab
	  M1 a6e8e7cc 25a75f6e 216583f7 ff3dc4cf
	  M2 12a3343b b453bb54 08da42d2 0c2d0fc8
	  M3 01010200 56123737 bfce00a7 13702dcf
	  M4 c1
	  AES_CMAC e3c47398 9cd0e8c5 d26c0b09 da958f61
	 ******************************************************/
	{
		uint8_t n1[] = {0xd5,0xcb,0x84,0x54,0xd1,0x77,0x73,0x3e,0xff,0xff,0xb2,0xec,0x71,0x2b,0xae,0xab,};
		uint8_t n2[] = {0xa6,0xe8,0xe7,0xcc,0x25,0xa7,0x5f,0x6e,0x21,0x65,0x83,0xf7,0xff,0x3d,0xc4,0xcf,};
		uint8_t MacKey[] = {0x29,0x65,0xf1,0x76,0xa1,0x08,0x4a,0x02,0xfd,0x3f,0x6a,0x20,0xce,0x63,0x6e,0x20,};
		uint8_t r[] = {0x12,0xa3,0x34,0x3b,0xb4,0x53,0xbb,0x54,0x08,0xda,0x42,0xd2,0x0c,0x2d,0x0f,0xc8,};
		uint8_t IOcap[] = {0x01,0x01,0x02,};
		uint8_t a1[] = { 0x00,0x56,0x12,0x37,0x37,0xbf,0xce, };
		uint8_t a2[] = { 0x00,0xa7,0x13,0x70,0x2d,0xcf,0xc1, };
		btc_f6(MacKey, n1, n2, r, IOcap, a1, a2, out);
		DUMP(out, 16);
	}


	/******************************************************
	  D.5 g2 LE SC NUMERIC COMPARISON GENERATION
	  FUNCTION
	  U 20b003d2 f297be2c 5e2c83a7 e9f9a5b9
	  eff49111 acf4fddb cc030148 0e359de6
	  V 55188b3d 32f6bb9a 900afcfb eed4e72a
	  59cb9ac2 f19d7cfb 6b4fdd49 f47fc5fd
	  X d5cb8454 d177733e ffffb2ec 712baeab
	  Y a6e8e7cc 25a75f6e 216583f7 ff3dc4cf
	  M0 20b003d2 f297be2c 5e2c83a7 e9f9a5b9
	  M1 eff49111 acf4fddb cc030148 0e359de6
	  M2 55188b3d 32f6bb9a 900afcfb eed4e72a
	  M3 59cb9ac2 f19d7cfb 6b4fdd49 f47fc5fd
	  M4 a6e8e7cc 25a75f6e 216583f7 ff3dc4cf
	  AES_CMAC 1536d18d e3d20df9 9b7044c1 2f9ed5ba
	  g2 2f9ed5ba
	 ******************************************************/
	{
		uint8_t u[] = {
			0x20,0xb0,0x03,0xd2,0xf2,0x97,0xbe,0x2c,0x5e,0x2c,0x83,0xa7,0xe9,0xf9,0xa5,0xb9,
			0xef,0xf4,0x91,0x11,0xac,0xf4,0xfd,0xdb,0xcc,0x03,0x01,0x48,0x0e,0x35,0x9d,0xe6,
		};
		uint8_t v[] = {
			0x55,0x18,0x8b,0x3d,0x32,0xf6,0xbb,0x9a,0x90,0x0a,0xfc,0xfb,0xee,0xd4,0xe7,0x2a,
			0x59,0xcb,0x9a,0xc2,0xf1,0x9d,0x7c,0xfb,0x6b,0x4f,0xdd,0x49,0xf4,0x7f,0xc5,0xfd,
		};
		uint8_t x[] = {0xd5,0xcb,0x84,0x54,0xd1,0x77,0x73,0x3e,0xff,0xff,0xb2,0xec,0x71,0x2b,0xae,0xab,};
		uint8_t y[] = {0xa6,0xe8,0xe7,0xcc,0x25,0xa7,0x5f,0x6e,0x21,0x65,0x83,0xf7,0xff,0x3d,0xc4,0xcf,};
		printf("0x%08x\n", btc_g2(u, v, x, y));
	}

	/******************************************************
	  D.6 h6 LE SC LINK KEY CONVERSION FUNCTION
	  Key ec0234a3 57c8ad05 341010a6 0a397d9b
	  keyID 6c656272
	  M 6c656272
	  AES_CMAC 2d9ae102 e76dc91c e8d3a9e2 80b16399
	 ******************************************************/
	{
		uint8_t Key[] = {0xec,0x02,0x34,0xa3,0x57,0xc8,0xad,0x05,0x34,0x10,0x10,0xa6,0x0a,0x39,0x7d,0x9b,};
		uint8_t keyID[] = { 0x6c,0x65,0x62,0x72, };
		btc_h6(Key, keyID, out);
		DUMP(out, 16);
	}

	/******************************************************
	  D.7 ah RANDOM ADDRESS HASH FUNCTIONS
	  IRK ec0234a3 57c8ad05 341010a6 0a397d9b
	  prand 00000000 00000000 00000000 00708194
	  M 00000000 00000000 00000000 00708194
	  AES_128 159d5fb7 2ebe2311 a48c1bdc c40dfbaa
	  ah 0dfbaa
	 ******************************************************/
	{
		uint8_t IRK[] = {0xec,0x02,0x34,0xa3,0x57,0xc8,0xad,0x05,0x34,0x10,0x10,0xa6,0x0a,0x39,0x7d,0x9b,};
		uint8_t prand[] = {0x70,0x81,0x94,};
		btc_ah(IRK, prand, out);
		DUMP(out, 3);
	}

	/******************************************************
	  D.8 h7 LE SC LINK KEY CONVERSION FUNCTION
	  Key ec0234a3 57c8ad05 341010a6 0a397d9b
	  SALT 00000000 00000000 00000000 746D7031
	  AES_CMAC fb173597 c6a3c0ec d2998c2a 75a57011
	 ******************************************************/
	{
		uint8_t Key[] = {0xec,0x02,0x34,0xa3,0x57,0xc8,0xad,0x05,0x34,0x10,0x10,0xa6,0x0a,0x39,0x7d,0x9b,};
		uint8_t SALT[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x6D,0x70,0x31,};
		btc_h7(SALT, Key, out);
		DUMP(out, 16);
	}

	{
		uint8_t out[32];
		uint8_t tk[16] = {0};
		uint8_t rand[] = {0xF5,0xCE,0xFC,0xDF,0xA4,0xDB,0x2B,0x5B,0x0F,0xC0,0x3A,0x94,0x47,0x9A,0xA2,0x49};
		uint8_t req[] = {0x01,0x04,0x00,0x01,0x10,0x03,0x03};
		uint8_t resp[] = {0x02,0x03,0x00,0x01,0x10,0x01,0x01};
		uint8_t iat = 1;
		uint8_t rat = 0;
		uint8_t ia[] = {0x8F,0xE1,0x2D,0x7D,0xA8,0x46};
		uint8_t ra[] = {0x78,0x28,0x00,0x86,0x19,0x00};
		btc_legacy_confirm(tk, rand, req, resp, iat, ia, rat, ra, out);
		/* 09 2A B4 A8 C1 B8 8F 3A 6E 97 9A 87 55 C3 18 0B */
		DUMP(out, 16);
	}

	{
		memcpy(out, "66666666666666666", 17);
		btc_e((uint8_t*)"1234567890123456", out);
		DUMP(out, 16);
	}

	/******************************************************
	  Private A: 3f49f6d4 a3c55f38 74c9b3e3 d2103f50 4aff607b eb40b799 5899b8a6 cd3c1abd
	  Private B: 55188b3d 32f6bb9a 900afcfb eed4e72a 59cb9ac2 f19d7cfb 6b4fdd49 f47fc5fd
	  Public A(x): 20b003d2 f297be2c 5e2c83a7 e9f9a5b9 eff49111 acf4fddb cc030148 0e359de6
	  Public A(y): dc809c49 652aeb6d 63329abf 5a52155c 766345c2 8fed3024 741c8ed0 1589d28b
	  Public B(x): 1ea1f0f0 1faf1d96 09592284 f19e4c00 47b58afd 8615a69f 559077b2 2faaa190
	  Public B(y): 4c55f33e 429dad37 7356703a 9ab85160 472d1130 e28e3676 5f89aff9 15b1214a
	  DHKey: ec0234a3 57c8ad05 341010a6 0a397d9b 99796b13 b4f866f1 868d34f3 73bfa698
	 ******************************************************/
	{
		uint8_t secret[32];
		uint8_t private_keyA[32] = {
			0x3f,0x49,0xf6,0xd4,0xa3,0xc5,0x5f,0x38,0x74,0xc9,0xb3,0xe3,0xd2,0x10,0x3f,0x50,
			0x4a,0xff,0x60,0x7b,0xeb,0x40,0xb7,0x99,0x58,0x99,0xb8,0xa6,0xcd,0x3c,0x1a,0xbd,
		};
		uint8_t public_keyA[64] = {
			0x20,0xb0,0x03,0xd2,0xf2,0x97,0xbe,0x2c,0x5e,0x2c,0x83,0xa7,0xe9,0xf9,0xa5,0xb9,
			0xef,0xf4,0x91,0x11,0xac,0xf4,0xfd,0xdb,0xcc,0x03,0x01,0x48,0x0e,0x35,0x9d,0xe6,
			0xdc,0x80,0x9c,0x49,0x65,0x2a,0xeb,0x6d,0x63,0x32,0x9a,0xbf,0x5a,0x52,0x15,0x5c,
			0x76,0x63,0x45,0xc2,0x8f,0xed,0x30,0x24,0x74,0x1c,0x8e,0xd0,0x15,0x89,0xd2,0x8b,
		};
		uint8_t private_keyB[32] = {
			0x55,0x18,0x8b,0x3d,0x32,0xf6,0xbb,0x9a,0x90,0x0a,0xfc,0xfb,0xee,0xd4,0xe7,0x2a,
			0x59,0xcb,0x9a,0xc2,0xf1,0x9d,0x7c,0xfb,0x6b,0x4f,0xdd,0x49,0xf4,0x7f,0xc5,0xfd,
		};
		uint8_t public_keyB[64] = {
			0x1e,0xa1,0xf0,0xf0,0x1f,0xaf,0x1d,0x96,0x09,0x59,0x22,0x84,0xf1,0x9e,0x4c,0x00,
			0x47,0xb5,0x8a,0xfd,0x86,0x15,0xa6,0x9f,0x55,0x90,0x77,0xb2,0x2f,0xaa,0xa1,0x90,
			0x4c,0x55,0xf3,0x3e,0x42,0x9d,0xad,0x37,0x73,0x56,0x70,0x3a,0x9a,0xb8,0x51,0x60,
			0x47,0x2d,0x11,0x30,0xe2,0x8e,0x36,0x76,0x5f,0x89,0xaf,0xf9,0x15,0xb1,0x21,0x4a,
		};
		btc_dhkey(public_keyA, private_keyB, out);
		DUMP(out, 32);
		btc_dhkey(public_keyB, private_keyA, out);
		DUMP(out, 32);
	}

	{
	/******************************************************
	 ** M: Pairing request
	 * 02 0B 07 00 06 00 01<04 00 2D>10 0F 0F BF 18 F1
	 ** S: Pairing response
	 * 16 0B 07 00 06 00 02<03 00 0D>10 03 03 1F 69 38
	 ** M: Public Key
	 * EE 70 32 9D B3 3A 6B 04 F4 BD E0 A0 0F 24 65 A9
	 * C9 B8 5F A2 6C 93 00 63 E4 F9 E9 27 E8 52 3E 49
	 * AD 4A 14 F7 56 F8 B9 E9 46 59 5F 42 F5 6C F5 C4
	 * 32 31 EF C5 F5 50 07 96 41 8C 10 09 93 5D E0 D9
	 ** S: Public Key
	 * E6 9D 35 0E 48 01 03 CC DB FD F4 AC 11 91 F4 EF
	 * B9 A5 F9 E9 A7 83 2C 5E 2C BE 97 F2 D2 03 B0 20
	 * 8B D2 89 15 D0 8E 1C 74 24 30 ED 8F C2 45 63 76
	 * 5C 15 52 5A BF 9A 32 63 6D EB 2A 65 49 9C 80 DC
	 ** M: Pairing Random(Na)
	 * 6F 35 35 AB 87 57 B8 8A EF 17 DB 80 31 FE 9A 15
	 ** S: Pairing Random(Nb)
	 * F3 F2 8E 10 43 A5 1C 08 9B 1D F5 4A B7 83 B8 76
	 ** S: Pairing Confirm(Cb)
	 * 5A 1A 24 33 9A B2 5A BA 2C 99 82 85 E6 A8 D3 B2
	 ** M&S: LTK
	 * 64 45 A1 8B 7F F3 78 02 6E 3A DF 1B 61 A1 26 B4
	 ** M: DHKey Check(Ea)
	 * A0 0E CA 20 CA E1 00 C9 F9 62 DD 4C 01 3F 89 79
	 ** S: DHKey Check(Eb)
	 * 77 80 54 6A 47 FC 7F 1E 21 E4 AE 13 78 4D 2C 7E
	 ******************************************************/

		uint8_t secret[32], out[64];
		uint8_t private_key[32] = {
			0x3f,0x49,0xf6,0xd4,0xa3,0xc5,0x5f,0x38,0x74,0xc9,0xb3,0xe3,0xd2,0x10,0x3f,0x50,
			0x4a,0xff,0x60,0x7b,0xeb,0x40,0xb7,0x99,0x58,0x99,0xb8,0xa6,0xcd,0x3c,0x1a,0xbd,
		};
		uint8_t pkB[64] = {
			0xE6,0x9D,0x35,0x0E,0x48,0x01,0x03,0xCC,0xDB,0xFD,0xF4,0xAC,0x11,0x91,0xF4,0xEF,
			0xB9,0xA5,0xF9,0xE9,0xA7,0x83,0x2C,0x5E,0x2C,0xBE,0x97,0xF2,0xD2,0x03,0xB0,0x20,
			0x8B,0xD2,0x89,0x15,0xD0,0x8E,0x1C,0x74,0x24,0x30,0xED,0x8F,0xC2,0x45,0x63,0x76,
			0x5C,0x15,0x52,0x5A,0xBF,0x9A,0x32,0x63,0x6D,0xEB,0x2A,0x65,0x49,0x9C,0x80,0xDC
		};
		uint8_t pkA[64] = {
			0xEE,0x70,0x32,0x9D,0xB3,0x3A,0x6B,0x04,0xF4,0xBD,0xE0,0xA0,0x0F,0x24,0x65,0xA9,
			0xC9,0xB8,0x5F,0xA2,0x6C,0x93,0x00,0x63,0xE4,0xF9,0xE9,0x27,0xE8,0x52,0x3E,0x49,
			0xAD,0x4A,0x14,0xF7,0x56,0xF8,0xB9,0xE9,0x46,0x59,0x5F,0x42,0xF5,0x6C,0xF5,0xC4,
			0x32,0x31,0xEF,0xC5,0xF5,0x50,0x07,0x96,0x41,0x8C,0x10,0x09,0x93,0x5D,0xE0,0xD9
		};
		brev(pkB, 32); brev(&pkB[32], 32);
		brev(pkA, 32); brev(&pkA[32], 32);
		{// Just debug endian.
			uint8_t prk0[32], pk0[64];
			uECC_make_key(pk0, prk0, uECC_secp256r1());
			brev(prk0, 32); brev(pk0, 32); brev(&pk0[32], 32);
			btc_dhkey(pk0, private_key, out);
			printf("\n: ");DUMP(out, 16);
			btc_dhkey(pkB, prk0, out);
			printf(": ");DUMP(out, 16);
		}
		uint8_t randB[32] = {
			0xF3,0xF2,0x8E,0x10,0x43,0xA5,0x1C,0x08,0x9B,0x1D,0xF5,0x4A,0xB7,0x83,0xB8,0x76
		};
		uint8_t randA[32] = {
			0x6F,0x35,0x35,0xAB,0x87,0x57,0xB8,0x8A,0xEF,0x17,0xDB,0x80,0x31,0xFE,0x9A,0x15
		};
		btc_sc_confirm(pkB, pkA, randB, 0, out);
		printf("sc_confirm: ");DUMP(out, 16);
		uint8_t dhkey[32];
		uint8_t ia[] = { 0x78, 0x20, 0x46, 0xaf, 0x08, 0x73, 0x01};
		uint8_t ra[] = { 0xf5, 0x5f, 0x21, 0x66, 0xbf, 0x01, 0x00};

		btc_dhkey(pkA, private_key, dhkey);
		printf("sc_dhkey:   ");DUMP(dhkey, 32);

		uint8_t macKey_LTK[32];
		btc_mackey_ltk(dhkey, randA, randB, ia, ra, macKey_LTK);
		printf("sc_macKey:  ");DUMP(macKey_LTK, 16);
		printf("sc_LTK:     ");DUMP(&macKey_LTK[16], 16);

		uint8_t iocapA[] = { 0x04, 0x00, 0x2D };
		uint8_t iocapB[] = { 0x03, 0x00, 0x0D };
		btc_dhkey_check(macKey_LTK, randA, randB, NULL, iocapA, ia, ra, out);
		printf("DHKey(Ea):  "); DUMP(out, 16);
		btc_dhkey_check(macKey_LTK, randB, randA, NULL, iocapB, ra, ia, out);
		printf("DHKey(Eb):  "); DUMP(out, 16);
	}
	{
	/******************************************************
	 * Long Term Key: 6445a18b7ff378026e3adf1b61a126b4
	 * LCP Encryption Request
	 * 	03 17 03 00 00 00 00 00 00 00 00 00 00 6D 4B F5 8E B9 6D 2F DD 8F A7 24 85
	 * SKDm (Session Key Diversifier Master Portion)
	 * 	6D 4B F5 8E B9 6D 2F DD
	 * IVm (Init. Vector Master Portion)
	 * 	8F A7 24 85
	 * LCP Encryption Response
	 * 	1B 0D 04 EC D4 DB 64 70 F7 AE 2D 28 1D F6 AC
	 * SKDs (Session Key Diversifier Slave Portion)
	 * 	EC D4 DB 64 70 F7 AE 2D
	 * IVs (Init. Vector Slave Portion)
	 * 	28 1D F6 AC

	 * LLCP Start Encryption Request(1B 01 05 FD D4 FA)
	 * LLCP Start Encryption Response(Master)
	 * 	Plaintext: 0F 05 06 92 D4 6E D7 F8 FD 14
	 * 	encrypted: 0F 05 47 78 E7 DB 90 F8 FD 14
	 * LLCP Start Encryption Response(Slave)
	 * 	Plaintext: 17 05 06 F6 BF 9D 49 AD DB 78
	 * 	encrypted: 17 05 C8 EB 9C 0A 0C AD DB 78
	 ******************************************************/
		uint8_t ltk[] = {
			0x64,0x45,0xa1,0x8b,0x7f,0xf3,0x78,0x02,0x6e,0x3a,0xdf,0x1b,0x61,0xa1,0x26,0xb4
		};
		uint8_t SKDm[] = {0x6D,0x4B,0xF5,0x8E,0xB9,0x6D,0x2F,0xDD};
		uint8_t SKDs[] = {0xEC,0xD4,0xDB,0x64,0x70,0xF7,0xAE,0x2D};
		uint8_t IVm[] = {0x8F,0xA7,0x24,0x85};
		uint8_t IVs[] = {0x28,0x1D,0xF6,0xAC};

		uint8_t llid_master = 0x0F, llid_slave = 0x17, mic[4];
		uint8_t plaintext_master[] = {0x06}; uint8_t plaintext_slave[] = {0x06};

		btc_ll_enc_ctx_t ctx;
		btc_ll_enc_ctx(SKDm, SKDs, ltk, IVm, IVs, &ctx);

		btc_ll_encrypt(&ctx, 0, 1, llid_master, plaintext_master, sizeof(plaintext_master), NULL, mic);
		printf("LL encrypted data(M): "); DUMP(plaintext_master, sizeof(plaintext_master));
		printf("LL encrypted mic(M):  "); DUMP(mic, 4);
		btc_ll_decrypt(&ctx, llid_master, plaintext_master, sizeof(plaintext_master), NULL, mic);
		printf("LL decrypted data(M): "); DUMP(plaintext_master, sizeof(plaintext_master));

		btc_ll_encrypt(&ctx, 0, 0, llid_slave, plaintext_slave, sizeof(plaintext_slave), NULL, mic);
		printf("LL encrypted data(S): "); DUMP(plaintext_slave, sizeof(plaintext_slave));
		printf("LL encrypted mic(S):  "); DUMP(mic, 4);
		btc_ll_decrypt(&ctx, llid_master, plaintext_slave, sizeof(plaintext_slave), NULL, mic);
		printf("LL decrypted data(S): "); DUMP(plaintext_slave, sizeof(plaintext_slave));
	}

	{
	/******************************************************
	 * Connection Request Packet:
	 *   45 22 78 20 46 AF 08 73 F5 5F 21 66 BF 01 49 EC 5B 8D 99 2A
	 *   5B 02 0D 00 24 00 00 00 F4 01 FF FF FF FF 1F 0A A0 47 AB
	 *   CRC: A0 47 AB
	 *
	 * LLCP Start Encryption Response(Master)
	 * 	encrypted: 0F 05 47 78 E7 DB 90
	 * 	CRC: F8 FD 14
	 * LLCP Start Encryption Response(Slave)
	 * 	encrypted: 17 05 C8 EB 9C 0A 0C
	 * 	CRC: AD DB 78

	 */
		uint8_t plaintext[] = {
			0x45,0x22,0x78,0x20,0x46,0xAF,0x08,0x73,0xF5,0x5F,0x21,0x66,0xBF,0x01,0x49,0xEC,
			0x5B,0x8D,0x99,0x2A,0x5B,0x02,0x0D,0x00,0x24,0x00,0x00,0x00,0xF4,0x01,0xFF,0xFF,
			0xFF,0xFF,0x1F,0x0A
		};
		printf("0x%06X\n", btc_crc24(0x555555, plaintext, sizeof(plaintext)));
		uint32_t crc_init = 0x5b2a99; // 99 2a 5b
		//uint32_t crc_init = 0x6654da; // 99 2a 5b
		uint8_t encryptedtext1[] = { 0x0F,0x05,0x47,0x78,0xE7,0xDB,0x90 };
		uint8_t encryptedtext2[] = { 0x17,0x05,0xC8,0xEB,0x9C,0x0A,0x0C };
		printf("0x%06X\n", btc_crc24(crc_init, encryptedtext1, sizeof(encryptedtext1)));
		printf("0x%06X\n", btc_crc24(crc_init, encryptedtext2, sizeof(encryptedtext2)));
	}

	{
	/******************************************************
	 * Raw Data1 ( channel index = 39)
	 *   0x20,0x20,0xF5,0x5F,0x21,0x66,0xBF,0x01,0x02,0x01,0x06,0x03,0x19,0xC2,0x03,0x03,
	 *   0x03,0x12,0x18,0x0E,0x08,0x52,0x57,0x2D,0x42,0x4C,0x45,0x2D,0x53,0x49,0x4D,0x50,
	 *   0x4C,0x45,0x70,0x11,0x87
	 * Whitened Data1
	 *   0x3F,0x17,0xBF,0x00,0xA4,0x90,0x23,0x9B,0xC3,0xD7,0xC3,0x47,0x39,0x9B,0xDD,0xE2,
	 *   0x8C,0x09,0xBD,0xA1,0x4A,0x29,0x19,0xE0,0x22,0xA7,0x27,0x0F,0xC3,0x65,0xA2,0xA0,
	 *   0x8B,0xC8,0xA2,0x46,0x26
	 * Raw Data2 ( channel index = 3)
	 *   0x0D,0x00,0x8B,0x37,0x1D
	 * Whitened Data2
	 *   0x16,0xA5,0x24,0x75,0x66
	 */
		uint8_t data1[] = {
			0x20,0x20,0xF5,0x5F,0x21,0x66,0xBF,0x01,0x02,0x01,0x06,0x03,0x19,0xC2,0x03,0x03,
			0x03,0x12,0x18,0x0E,0x08,0x52,0x57,0x2D,0x42,0x4C,0x45,0x2D,0x53,0x49,0x4D,0x50,
			0x4C,0x45,0x70,0x11,0x87
		};
		btc_whitening(data1, sizeof(data1), 39);
		DUMP(data1, sizeof(data1));
		uint8_t data2[] = { 0x0D,0x00,0x8B,0x37,0x1D };
		btc_whitening(data2, sizeof(data2), 3);
		DUMP(data2, sizeof(data2));
	}
}

int main()
{
	test();
}
